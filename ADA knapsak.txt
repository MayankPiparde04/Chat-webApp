ADA knapsack

unction to solve 0-1 Knapsack problem using dynamic programming
int knapSack(int W, int wt[], int val[], int n) {
    // Create a DP table to store the maximum profit for each subproblem
    vector<vector<int>> table(n + 1, vector<int>(W + 1));

    // Fill the table
    for (int i = 0; i <= n; i++) {
        for (int w = 0; w <= W; w++) {
            if (i == 0 || w == 0) {
                table[i][w] = 0; // Base case: no items or no capacity
            } else if (wt[i - 1] <= w) {
                // Include the item or exclude it, whichever is better
                table[i][w] = max(val[i - 1] + table[i - 1][w - wt[i - 1]], table[i - 1][w]);
            } else {
                table[i][w] = table[i - 1][w]; // Cannot include the item
            }
        }
    }

    return table[n][W];
}

// Driver code
int main() {
    int profit[] = { 6, 10, 12 };
    int weight[] = { 1, 3, 4 };
    int W = 5;
    int n = sizeof(profit) / sizeof(profit[0]);

    cout << "Maximum profit: " << knapSack(W, weight, profit, n) << endl;

    return 0;
}
